<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PJM Load Forecast Convergence</title>

    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
      .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .badge { padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; font-size: 14px; }
      .hint { color: #666; font-size: 13px; margin-top: 6px; }

      .panel { margin-top: 18px; padding-top: 14px; border-top: 1px solid #eee; }
      .panel h3 { margin: 0; font-size: 18px; }
      .panel .sub { color: #666; font-size: 13px; margin-top: 4px; }

      .chart { width: 100%; height: 58vh; margin-top: 10px; }

      .section-title { margin: 12px 0 8px; font-size: 15px; font-weight: 650; }

      .table-wrap { border: 1px solid #e5e5e5; border-radius: 10px; overflow: hidden; }
      .table-scroll { overflow: auto; max-height: 55vh; background: #fff; }
      table { border-collapse: collapse; width: max-content; min-width: 100%; }
      th, td { border: 1px solid #eee; padding: 6px 8px; font-size: 12px; white-space: nowrap; }
      th { position: sticky; top: 0; background: #fafafa; z-index: 2; font-weight: 650; }
      th.sticky-left, td.sticky-left { position: sticky; left: 0; z-index: 3; background: #fafafa; font-weight: 650; }
      td.sticky-left { background: #fff; font-weight: 600; }
      .cell { text-align: right; min-width: 84px; }
      .mono { font-variant-numeric: tabular-nums; }
    </style>
  </head>

  <body>
    <div class="row">
      <h2 style="margin:0;">PJM Load Forecast Convergence</h2>
      <div class="badge" id="status">Loading…</div>
    </div>
    <div class="hint">
      Two datasets: Hourly (7day) and 5-minute (very short). Latest run is red. Times shown in ET.
    </div>

    <!-- PANEL: 7DAY -->
    <div class="panel">
      <div class="row">
        <h3>Hourly Load Forecast (7day feed)</h3>
        <div class="badge" id="badge-7day">Loading…</div>
      </div>
      <div class="sub">
        Chart shows the latest 12 forecast updates. Now line is in ET. Chart is clipped to midnight ET today.
      </div>

      <div id="chart-7day" class="chart"></div>

      <div class="section-title">Forecast Matrix (Forecast release × Load datetime)</div>
      <div class="table-wrap">
        <div class="table-scroll" id="table-7day"></div>
      </div>
    </div>

    <!-- PANEL: VSHORT -->
    <div class="panel">
      <div class="row">
        <h3>Very Short Load Forecast (5-minute feed)</h3>
        <div class="badge" id="badge-vshort">Loading…</div>
      </div>
      <div class="sub">
        This feed is ~2 hours forward in 5-minute steps. Same visualization logic as hourly. Chart is clipped to midnight ET today.
      </div>

      <div id="chart-vshort" class="chart"></div>

      <div class="section-title">Forecast Matrix (Forecast release × Load datetime)</div>
      <div class="table-wrap">
        <div class="table-scroll" id="table-vshort"></div>
      </div>
    </div>

    <script>
      const AREA = "RTO_COMBINED";
      const TIMEZONE = "America/New_York";

      const MAX_RUNS = 12;

      // Table trimming behavior: keep your existing intent (current hour - 1)
      const TABLE_LOOKBACK_HOURS = 1;

      const COLOR_LATEST = "#d62728";
      const COLOR_OLD = "#1f77b4";

      // ---- Time helpers (ET) ----

      function etNow() {
        // Date object whose wall-clock matches ET (constructed via locale string)
        return new Date(new Date().toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function etFromIso(isoUtc) {
        return new Date(new Date(isoUtc).toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function etMidnightToday() {
        const n = etNow();
        const d = new Date(n);
        d.setHours(0, 0, 0, 0);
        return d;
      }

      function floorToHour(d) {
        const x = new Date(d);
        x.setMinutes(0, 0, 0);
        return x;
      }

      function fmtET(dt) {
        // dt is already an ET-wallclock Date
        const yyyy = dt.getFullYear();
        const mm = String(dt.getMonth() + 1).padStart(2, "0");
        const dd = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mi = String(dt.getMinutes()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
      }

      function fmtETShort(dt) {
        // MM-DD HH:MM
        const mm = String(dt.getMonth() + 1).padStart(2, "0");
        const dd = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mi = String(dt.getMinutes()).padStart(2, "0");
        return `${mm}-${dd} ${hh}:${mi}`;
      }

      function fmtMW(v) {
        return Math.round(v).toLocaleString("en-US");
      }

      // ---- Table shading ----

      function colorForColumnRelative(t) {
        if (t === null || !isFinite(t)) return "rgba(0,0,0,0.03)";
        const dist = Math.abs(t - 0.5) * 2;
        const alpha = 0.10 + 0.65 * Math.pow(dist, 0.85);
        return t > 0.5
          ? `rgba(220,53,69,${alpha})`   // red
          : `rgba(40,167,69,${alpha})`;  // green
      }

      function buildMatrixTable(runs, tableElId) {
        const runsSorted = [...runs].sort((a,b) => new Date(a.run_ts) - new Date(b.run_ts));

        const colSet = new Set();
        runsSorted.forEach(r => r.points.forEach(p => colSet.add(p.target_ts)));

        const colUtcAll = [...colSet].sort((a,b)=>new Date(a)-new Date(b));
        const colEtAll  = colUtcAll.map(etFromIso);

        const nowET = etNow();
        const tableStartET = new Date(floorToHour(nowET).getTime() - TABLE_LOOKBACK_HOURS*3600000);

        const keptIdx = colEtAll
          .map((d,i)=>({d,i}))
          .filter(o => o.d >= tableStartET)
          .map(o => o.i);

        const colUtc = keptIdx.map(i => colUtcAll[i]);
        const colEt  = keptIdx.map(i => colEtAll[i]);

        const mwMaps = runsSorted.map(r => {
          const m = new Map();
          r.points.forEach(p => m.set(p.target_ts, p.mw));
          return m;
        });

        const colMinMax = colUtc.map(ts => {
          const vals = mwMaps.map(m => m.get(ts)).filter(v => v != null);
          return vals.length ? {min: Math.min(...vals), max: Math.max(...vals)} : {min: null, max: null};
        });

        let html = "<table><thead><tr>";
        html += "<th class='sticky-left'>Forecast release (ET)</th>";
        colEt.forEach(d => html += `<th class="mono">${fmtETShort(d)}</th>`);
        html += "</tr></thead><tbody>";

        for (let i = runsSorted.length - 1; i >= 0; i--) {
          const runEt = etFromIso(runsSorted[i].run_ts);
          html += `<tr><td class="sticky-left mono">${fmtET(runEt)}</td>`;

          colUtc.forEach((ts,j) => {
            const mw = mwMaps[i].get(ts);
            const mm = colMinMax[j];
            let t = null;
            if (mw != null && mm.min != null && mm.max != null && mm.max !== mm.min) {
              t = (mw - mm.min) / (mm.max - mm.min);
            }
            const bg = colorForColumnRelative(t);
            html += `<td class="cell mono" style="background:${bg}">${mw != null ? fmtMW(mw) : ""}</td>`;
          });

          html += "</tr>";
        }

        html += "</tbody></table>";
        document.getElementById(tableElId).innerHTML = html;
      }

      // ---- Plotly helpers ----

      function buildNowLineShape(nowEtDate) {
        return {
          name: "nowLine",
          type: "line",
          xref: "x",
          yref: "paper",
          x0: nowEtDate,
          x1: nowEtDate,
          y0: 0,
          y1: 1,
          line: { width: 2, dash: "dot" }
        };
      }

      function buildNowLabelAnnotation(nowEtDate) {
        return {
          x: nowEtDate,
          y: 1,
          xref: "x",
          yref: "paper",
          xanchor: "left",
          yanchor: "bottom",
          text: "Now",
          showarrow: false,
          font: { size: 12 }
        };
      }

      function sortRunsAsc(runs) {
        return [...runs].sort((a,b) => new Date(a.run_ts) - new Date(b.run_ts));
      }

      function chooseNewestRunTs(runs) {
        return runs.reduce((acc, r) => {
          const t = new Date(r.run_ts).getTime();
          return Math.max(acc, t);
        }, 0);
      }

      async function renderPanel(feed, chartElId, badgeElId, tableElId, sinceHours) {
        // Latest ingest badge (display as ET)
        const latest = await (await fetch(`/api/latest?feed=${encodeURIComponent(feed)}&area=${encodeURIComponent(AREA)}`)).json();
        if (latest?.run_ts) {
          document.getElementById(badgeElId).textContent = `Last ingest (ET): ${fmtET(etFromIso(latest.run_ts))}`;
        } else {
          document.getElementById(badgeElId).textContent = "No data";
        }

        // Runs: server clips to midnight ET today + returns meta
        const url =
          `/api/runs?feed=${encodeURIComponent(feed)}&area=${encodeURIComponent(AREA)}` +
          `&since_hours=${sinceHours}&limit=${MAX_RUNS}&clip_to_midnight_et=true`;

        const data = await (await fetch(url)).json();

        if (!data?.runs?.length) {
          Plotly.purge(chartElId);
          document.getElementById(tableElId).innerHTML = "<div style='padding:10px;color:#666;'>No data yet.</div>";
          return;
        }

        const runs = sortRunsAsc(data.runs);
        const newestMs = chooseNewestRunTs(runs);

        // X-axis min: midnight ET today (client enforced)
        const xMin = etMidnightToday();

        // "Now" (ET): prefer server-provided, fallback to local ET
        const nowEt = data?.meta?.now_et ? etFromIso(data.meta.now_et) : etNow();

        // Build traces
        const traces = runs.map((r, i) => {
          const isLatest = new Date(r.run_ts).getTime() === newestMs;

          // Filter any stragglers before midnight ET (belt + suspenders)
          const pts = r.points
            .map(p => ({ x: etFromIso(p.target_ts), y: p.mw }))
            .filter(p => p.x >= xMin);

          const frac = (runs.length <= 1) ? 1 : i / (runs.length - 1);
          const opacity = isLatest ? 1 : (0.35 + 0.55 * Math.pow(frac, 0.8));

          return {
            x: pts.map(p => p.x),
            y: pts.map(p => p.y),
            mode: "lines",
            line: { color: isLatest ? COLOR_LATEST : COLOR_OLD, width: isLatest ? 2.6 : 1.2 },
            opacity,
            hovertemplate: "%{x|%m-%d %H:%M} ET<br>%{y:.0f} MW<extra></extra>"
          };
        });

        const layout = {
          xaxis: {
            title: "Time (ET)",
            range: [xMin, null] // clip to midnight ET today
          },
          yaxis: { title: "MW" },
          showlegend: false,
          margin: { l: 60, r: 20, t: 10, b: 50 },
          shapes: [buildNowLineShape(nowEt)],
          annotations: [buildNowLabelAnnotation(nowEt)]
        };

        await Plotly.newPlot(chartElId, traces, layout, { displayModeBar: false, responsive: true });

        // Table (keep your original behavior)
        buildMatrixTable(runs, tableElId);
      }

      async function loadAll() {
        const latest7 = await (await fetch(`/api/latest?feed=7day&area=${encodeURIComponent(AREA)}`)).json();
        document.getElementById("status").textContent =
          latest7?.run_ts ? `Last ingest (7day, ET): ${fmtET(etFromIso(latest7.run_ts))}` : "No data";

        await renderPanel("7day", "chart-7day", "badge-7day", "table-7day", 72);
        await renderPanel("vshort", "chart-vshort", "badge-vshort", "table-vshort", 24);
      }

      loadAll();
      setInterval(loadAll, 60000);
    </script>
  </body>
</html>
