<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PJM Load Forecast Convergence</title>

    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
      .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .badge { padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; font-size: 14px; }
      .hint { color: #666; font-size: 13px; margin-top: 6px; }

      .panel { margin-top: 18px; padding-top: 14px; border-top: 1px solid #eee; }
      .panel h3 { margin: 0; font-size: 18px; }
      .panel .sub { color: #666; font-size: 13px; margin-top: 4px; }

      .chart { width: 100%; height: 58vh; margin-top: 10px; }

      .section-title { margin: 12px 0 8px; font-size: 15px; font-weight: 650; }

      .table-wrap { border: 1px solid #e5e5e5; border-radius: 10px; overflow: hidden; }
      .table-scroll { overflow: auto; max-height: 55vh; background: #fff; }
      table { border-collapse: collapse; width: max-content; min-width: 100%; }
      th, td { border: 1px solid #eee; padding: 6px 8px; font-size: 12px; white-space: nowrap; }
      th { position: sticky; top: 0; background: #fafafa; z-index: 2; font-weight: 650; }
      th.sticky-left, td.sticky-left { position: sticky; left: 0; z-index: 3; background: #fafafa; font-weight: 650; }
      td.sticky-left { background: #fff; font-weight: 600; }
      .cell { text-align: right; min-width: 84px; }
      .mono { font-variant-numeric: tabular-nums; }
    </style>
  </head>

  <body>
    <div class="row">
      <h2 style="margin:0;">PJM Load Forecast Convergence</h2>
      <div class="badge" id="status">Loading…</div>
    </div>
    <div class="hint">
      Two datasets: Hourly (7day) and 5-minute (very short). Latest run is red. Times shown in ET.
    </div>

    <!-- PANEL: 7DAY -->
    <div class="panel">
      <div class="row">
        <h3>Hourly Load Forecast (7day feed)</h3>
        <div class="badge" id="badge-7day">Loading…</div>
      </div>
      <div class="sub">Chart shows the latest 12 forecast updates. Table shading is relative within each load timestamp column (green low → red high). Table trims past hours (start at ET current hour - 1).</div>

      <div id="chart-7day" class="chart"></div>

      <div class="section-title">Forecast Matrix (Forecast release × Load datetime)</div>
      <div class="table-wrap">
        <div class="table-scroll" id="table-7day"></div>
      </div>
    </div>

    <!-- PANEL: VSHORT -->
    <div class="panel">
      <div class="row">
        <h3>Very Short Load Forecast (5-minute feed)</h3>
        <div class="badge" id="badge-vshort">Loading…</div>
      </div>
      <div class="sub">This feed is ~2 hours forward in 5-minute steps. Same visualization logic as hourly.</div>

      <div id="chart-vshort" class="chart"></div>

      <div class="section-title">Forecast Matrix (Forecast release × Load datetime)</div>
      <div class="table-wrap">
        <div class="table-scroll" id="table-vshort"></div>
      </div>
    </div>

    <script>
      const AREA = "RTO_COMBINED";
      const TIMEZONE = "America/New_York";

      const MAX_RUNS = 12;
      const TABLE_LOOKBACK_HOURS = 1;

      const COLOR_LATEST = "#d62728";
      const COLOR_OLD = "#1f77b4";

      function toETDate(utcIso) {
        const d = new Date(utcIso);
        return new Date(d.toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function nowETDate() {
        return new Date(new Date().toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function floorToHour(d) {
        const x = new Date(d);
        x.setMinutes(0, 0, 0);
        return x;
      }

      function fmtET(dt) {
        return dt.toISOString().slice(0,16).replace("T"," ");
      }

      function fmtETShort(dt) {
        return fmtET(dt).slice(5);
      }

      function fmtMW(v) {
        return Math.round(v).toLocaleString("en-US");
      }

      function colorForColumnRelative(t) {
        if (t === null || !isFinite(t)) return "rgba(0,0,0,0.03)";
        const dist = Math.abs(t - 0.5) * 2;
        const alpha = 0.10 + 0.65 * Math.pow(dist, 0.85);
        return t > 0.5
          ? `rgba(220,53,69,${alpha})`   // red
          : `rgba(40,167,69,${alpha})`;  // green
      }

      function pickLatestRuns(runs) {
        return [...runs]
          .sort((a,b) => new Date(a.run_ts) - new Date(b.run_ts))
          .slice(-MAX_RUNS);
      }

      function buildMatrixTable(runs, tableElId) {
        const runsSorted = [...runs].sort((a,b) => new Date(a.run_ts) - new Date(b.run_ts));

        // columns = union of all target_ts
        const colSet = new Set();
        runsSorted.forEach(r => r.points.forEach(p => colSet.add(p.target_ts)));

        const colUtcAll = [...colSet].sort((a,b)=>new Date(a)-new Date(b));
        const colEtAll  = colUtcAll.map(toETDate);

        // table front trim: start at current ET hour - 1h
        const nowET = nowETDate();
        const tableStartET = new Date(floorToHour(nowET).getTime() - TABLE_LOOKBACK_HOURS*3600000);

        const keptIdx = colEtAll
          .map((d,i)=>({d,i}))
          .filter(o => o.d >= tableStartET)
          .map(o => o.i);

        const colUtc = keptIdx.map(i => colUtcAll[i]);
        const colEt  = keptIdx.map(i => colEtAll[i]);

        // map run -> target_ts -> mw
        const mwMaps = runsSorted.map(r => {
          const m = new Map();
          r.points.forEach(p => m.set(p.target_ts, p.mw));
          return m;
        });

        // per-column min/max across runs (for shading)
        const colMinMax = colUtc.map(ts => {
          const vals = mwMaps.map(m => m.get(ts)).filter(v => v != null);
          return vals.length ? {min: Math.min(...vals), max: Math.max(...vals)} : {min: null, max: null};
        });

        let html = "<table><thead><tr>";
        html += "<th class='sticky-left'>Forecast release (ET)</th>";
        colEt.forEach(d => html += `<th class="mono">${fmtETShort(d)}</th>`);
        html += "</tr></thead><tbody>";

        // newest at top
        for (let i = runsSorted.length - 1; i >= 0; i--) {
          const runEt = toETDate(runsSorted[i].run_ts);
          html += `<tr><td class="sticky-left mono">${fmtET(runEt)}</td>`;

          colUtc.forEach((ts,j) => {
            const mw = mwMaps[i].get(ts);
            const mm = colMinMax[j];
            let t = null;
            if (mw != null && mm.min != null && mm.max != null && mm.max !== mm.min) {
              t = (mw - mm.min) / (mm.max - mm.min);
            }
            const bg = colorForColumnRelative(t);
            html += `<td class="cell mono" style="background:${bg}">${mw != null ? fmtMW(mw) : ""}</td>`;
          });

          html += "</tr>";
        }

        html += "</tbody></table>";
        document.getElementById(tableElId).innerHTML = html;
      }

      async function renderPanel(feed, chartElId, badgeElId, tableElId, sinceHours) {
        // badge
        const latest = await (await fetch(`/api/latest?feed=${encodeURIComponent(feed)}&area=${encodeURIComponent(AREA)}`)).json();
        document.getElementById(badgeElId).textContent =
          latest?.run_ts ? `Last ingest: ${latest.run_ts}` : "No data";

        // runs
        const data = await (await fetch(`/api/runs?feed=${encodeURIComponent(feed)}&area=${encodeURIComponent(AREA)}&since_hours=${sinceHours}&limit=${MAX_RUNS}`)).json();
        if (!data?.runs?.length) {
          Plotly.purge(chartElId);
          document.getElementById(tableElId).innerHTML = "<div style='padding:10px;color:#666;'>No data yet.</div>";
          return;
        }

        const runs = pickLatestRuns(data.runs);

        // chart
        const newest = Math.max(...runs.map(r => new Date(r.run_ts).getTime()));
        const traces = runs.map((r, i) => {
          const isLatest = new Date(r.run_ts).getTime() === newest;

          // opacity ramp: old still visible
          const frac = (runs.length <= 1) ? 1 : i / (runs.length - 1); // older -> smaller i
          const opacity = isLatest ? 1 : (0.35 + 0.55 * Math.pow(frac, 0.8)); // 0.35..0.90

          return {
            x: r.points.map(p => toETDate(p.target_ts)),
            y: r.points.map(p => p.mw),
            mode: "lines",
            line: {
              color: isLatest ? COLOR_LATEST : COLOR_OLD,
              width: isLatest ? 2.6 : 1.2
            },
            opacity
          };
        });

        Plotly.newPlot(chartElId, traces, {
          xaxis: { title: "Hour (ET)" },
          yaxis: { title: "MW" },
          showlegend: false,
          margin: { l: 60, r: 20, t: 10, b: 50 }
        }, { displayModeBar: false });

        // table
        buildMatrixTable(runs, tableElId);
      }

      async function loadAll() {
        // overall status just shows web alive + last 7day ingest if present
        const latest7 = await (await fetch(`/api/latest?feed=7day&area=${AREA}`)).json();
        document.getElementById("status").textContent =
          latest7?.run_ts ? `Last ingest (7day): ${latest7.run_ts}` : "No data";

        // 7day: show last ~3 days of runs so you get 12 lines if you ingest often
        await renderPanel("7day", "chart-7day", "badge-7day", "table-7day", 72);

        // vshort: updates more often, but we still just want the latest 12 runs
        await renderPanel("vshort", "chart-vshort", "badge-vshort", "table-vshort", 24);
      }

      loadAll();
      setInterval(loadAll, 60000);
    </script>
  </body>
</html>
