<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PJM Load Forecast Convergence</title>

    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
      .row { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
      .badge { padding: 6px 10px; border: 1px solid #ddd; border-radius: 999px; font-size: 14px; }
      .hint { color: #666; font-size: 13px; margin-top: 6px; }

      .panel { margin-top: 18px; padding-top: 14px; border-top: 1px solid #eee; }
      .panel h3 { margin: 0; font-size: 18px; }
      .panel .sub { color: #666; font-size: 13px; margin-top: 4px; }

      .chart { width: 100%; height: 58vh; margin-top: 10px; }

      .section-title { margin: 12px 0 8px; font-size: 15px; font-weight: 650; }

      .table-wrap { border: 1px solid #e5e5e5; border-radius: 10px; overflow: hidden; }
      .table-scroll { overflow: auto; max-height: 55vh; background: #fff; }
      table { border-collapse: collapse; width: max-content; min-width: 100%; }
      th, td { border: 1px solid #eee; padding: 6px 8px; font-size: 12px; white-space: nowrap; }
      th { position: sticky; top: 0; background: #fafafa; z-index: 2; font-weight: 650; }
      th.sticky-left, td.sticky-left { position: sticky; left: 0; z-index: 3; background: #fafafa; font-weight: 650; }
      td.sticky-left { background: #fff; font-weight: 600; }
      .cell { text-align: right; min-width: 84px; }
      .mono { font-variant-numeric: tabular-nums; }
    </style>
  </head>

  <body>
    <div class="row">
      <h2 style="margin:0;">PJM Load Forecast Convergence</h2>
      <div class="badge" id="status">Loading…</div>
    </div>
    <div class="hint">
      Two datasets: Hourly (7day) and 5-minute (very short). Latest run is red. Times shown in ET.
    </div>

    <!-- PANEL: 7DAY -->
    <div class="panel">
      <div class="row">
        <h3>Hourly Load Forecast (7day feed)</h3>
        <div class="badge" id="badge-7day">Loading…</div>
      </div>
      <div class="sub">
        Chart shows the latest 12 forecast updates. Now line is in ET. Chart is clipped to midnight ET today.
      </div>

      <div id="chart-7day" class="chart"></div>

      <div class="section-title">Forecast Matrix (Forecast release × Load datetime)</div>
      <div class="table-wrap">
        <div class="table-scroll" id="table-7day"></div>
      </div>
    </div>

    <!-- PANEL: VSHORT -->
    <div class="panel">
      <div class="row">
        <h3>Very Short Load Forecast (5-minute feed)</h3>
        <div class="badge"/npm data is from an invalid parse, keep stable --> id="badge-vshort">Loading…</div>
      </div>
      <div class="sub">
        This feed is ~2 hours forward in 5-minute steps. Same visualization logic as hourly. Chart is clipped to midnight ET today.
      </div>

      <div id="chart-vshort" class="chart"></div>

      <div class="section-title">Forecast Matrix (Forecast release × Load datetime)</div>
      <div class="table-wrap">
        <div class="table-scroll" id="table-vshort"></div>
      </div>
    </div>

    <script>
      const AREA = "RTO_COMBINED";
      const TIMEZONE = "America/New_York";

      const MAX_RUNS = 12;

      // Table trimming behavior: keep your existing intent (current hour - 1)
      const TABLE_LOOKBACK_HOURS = 1;

      const COLOR_LATEST = "#d62728";
      const COLOR_OLD = "#1f77b4";

      // ---- Robust ET helpers (avoid parsing locale strings) ----
      // We intentionally create "ET wall-clock" Date objects by extracting ET parts,
      // then constructing a Date in *local* time with those parts. This matches your intent:
      // x-axis labels represent ET wall-clock.
      function etParts(date) {
        const fmt = new Intl.DateTimeFormat("en-US", {
          timeZone: TIMEZONE,
          year: "numeric", month: "2-digit", day: "2-digit",
          hour: "2-digit", minute: "2-digit", second: "2-digit",
          hour12: false
        });
        const partsArr = fmt.formatToParts(date);
        const parts = {};
        for (const p of partsArr) {
          if (p.type !== "literal") parts[p.type] = p.value;
        }
        return parts; // {year,month,day,hour,minute,second}
      }

      function etNow() {
        const p = etParts(new Date());
        return new Date(
          Number(p.year),
          Number(p.month) - 1,
          Number(p.day),
          Number(p.hour),
          Number(p.minute),
          Number(p.second),
          0
        );
      }

      function etFromIso(isoUtc) {
        // isoUtc is a UTC timestamp string from server; we convert to ET wall-clock parts.
        const d = new Date(isoUtc);
        if (Number.isNaN(d.getTime())) return null;
        const p = etParts(d);
        return new Date(
          Number(p.year),
          Number(p.month) - 1,
          Number(p.day),
          Number(p.hour),
          Number(p.minute),
          Number(p.second),
          0
        );
      }

      function etMidnightToday() {
        const n = etNow();
        const d = new Date(n);
        d.setHours(0, 0, 0, 0);
        return d;
      }

      function floorToHour(d) {
        const x = new Date(d);
        x.setMinutes(0, 0, 0);
        return x;
      }

      function fmtET(dt) {
        const yyyy = dt.getFullYear();
        const mm = String(dt.getMonth() + 1).padStart(2, "0");
        const dd = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mi = String(dt.getMinutes()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
      }

      function fmtETShort(dt) {
        const mm = String(dt.getMonth() + 1).padStart(2, "0");
        const dd = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mi = String(dt.getMinutes()).padStart(2, "0");
        return `${mm}-${dd} ${hh}:${mi}`;
      }

      function fmtMW(v) {
        return Math.round(v).toLocaleString("en-US");
      }

      // ---- Table shading ----
      function colorForColumnRelative(t) {
        if (t === null || !isFinite(t)) return "rgba(0,0,0,0.03)";
        const dist = Math.abs(t - 0.5) * 2;
        const alpha = 0.10 + 0.65 * Math.pow(dist, 0.85);
        return t > 0.5
          ? `rgba(220,53,69,${alpha})`   // red
          : `rgba(40,167,69,${alpha})`;  // green
      }

      function buildMatrixTable(runs, tableElId) {
        const runsSorted = [...runs].sort((a,b) => new Date(a.run_ts) - new Date(b.run_ts));

        const colSet = new Set();
        runsSorted.forEach(r => r.points.forEach(p => colSet.add(p.target_ts)));

        const colUtcAll = [...colSet].sort((a,b)=>new Date(a)-new Date(b));
        const colEtAll  = colUtcAll.map(etFromIso).filter(Boolean);

        const nowET = etNow();
        const tableStartET = new Date(floorToHour(nowET).getTime() - TABLE_LOOKBACK_HOURS*3600000);

        // Keep cols >= tableStartET. Need aligned indices between colUtcAll & colEtAll,
        // so rebuild with a loop rather than relying on filtering above.
        const colUtc = [];
        const colEt  = [];
        for (let i = 0; i < colUtcAll.length; i++) {
          const et = etFromIso(colUtcAll[i]);
          if (!et) continue;
          if (et >= tableStartET) {
            colUtc.push(colUtcAll[i]);
            colEt.push(et);
          }
        }

        const mwMaps = runsSorted.map(r => {
          const m = new Map();
          r.points.forEach(p => m.set(p.target_ts, p.mw));
          return m;
        });

        const colMinMax = colUtc.map(ts => {
          const vals = mwMaps.map(m => m.get(ts)).filter(v => v != null);
          return vals.length ? {min: Math.min(...vals), max: Math.max(...vals)} : {min: null, max: null};
        });

        let html = "<table><thead><tr>";
        html += "<th class='sticky-left'>Forecast release (ET)</th>";
        colEt.forEach(d => html += `<th class="mono">${fmtETShort(d)}</th>`);
        html += "</tr></thead><tbody>";

        for (let i = runsSorted.length - 1; i >= 0; i--) {
          const runEt = etFromIso(runsSorted[i].run_ts);
          html += `<tr><td class="sticky-left mono">${runEt ? fmtET(runEt) : ""}</td>`;

          colUtc.forEach((ts,j) => {
            const mw = mwMaps[i].get(ts);
            const mm = colMinMax[j];
            let t = null;
            if (mw != null && mm.min != null && mm.max != null && mm.max !== mm.min) {
              t = (mw - mm.min) / (mm.max - mm.min);
            }
            const bg = colorForColumnRelative(t);
            html += `<td class="cell mono" style="background:${bg}">${mw != null ? fmtMW(mw) : ""}</td>`;
          });

          html += "</tr>";
        }

        html += "</tbody></table>";
        document.getElementById(tableElId).innerHTML = html;
      }

      // ---- Plotly helpers ----
      function buildNowLineShape(nowEtDate) {
        return {
          name: "nowLine",
          type: "line",
          xref: "x",
          yref: "paper",
          x0: nowEtDate,
          x1: nowEtDate,
          y0: 0,
          y1: 1,
          line: { width: 2, dash: "dot" }
        };
      }

      function buildNowLabelAnnotation(nowEtDate) {
        return {
          x: nowEtDate,
          y: 1,
          xref: "x",
          yref: "paper",
          xanchor: "left",
          yanchor: "bottom",
          text: "Now",
          showarrow: false,
          font: { size: 12 }
        };
      }

      function sortRunsAsc(runs) {
        return [...runs].sort((a,b) => new Date(a.run_ts) - new Date(b.run_ts));
      }

      function chooseNewestRunTs(runs) {
        return runs.reduce((acc, r) => Math.max(acc, new Date(r.run_ts).getTime()), 0);
      }

      function computeXMaxFromTraces(traces, fallbackNow) {
        let maxMs = -Infinity;
        for (const t of traces) {
          if (!t.x || !t.x.length) continue;
          for (const x of t.x) {
            const ms = (x instanceof Date) ? x.getTime() : new Date(x).getTime();
            if (!Number.isNaN(ms)) maxMs = Math.max(maxMs, ms);
          }
        }
        if (!Number.isFinite(maxMs)) return new Date(fallbackNow.getTime() + 2 * 3600000);
        return new Date(maxMs);
      }

      // Keep last good plots so a bad/empty fetch can't blank the chart.
      const LAST_GOOD = {
        "chart-7day": null,
        "chart-vshort": null
      };

      // Data revision so Plotly reliably updates without tearing.
      const DATA_REV = {
        "chart-7day": 0,
        "chart-vshort": 0
      };

      async function renderPanel(feed, chartElId, badgeElId, tableElId, sinceHours) {
        // Latest ingest badge (display as ET)
        const latest = await (await fetch(`/api/latest?feed=${encodeURIComponent(feed)}&area=${encodeURIComponent(AREA)}`)).json();
        if (latest?.run_ts) {
          const t = etFromIso(latest.run_ts);
          document.getElementById(badgeElId).textContent = t ? `Last ingest (ET): ${fmtET(t)}` : "Last ingest (ET): ?";
        } else {
          document.getElementById(badgeElId).textContent = "No data";
        }

        const url =
          `/api/runs?feed=${encodeURIComponent(feed)}&area=${encodeURIComponent(AREA)}` +
          `&since_hours=${sinceHours}&limit=${MAX_RUNS}&clip_to_midnight_et=true`;

        const data = await (await fetch(url)).json();

        if (!data?.runs?.length) {
          // Do NOT purge here (that causes flicker). Keep last good plot.
          if (!LAST_GOOD[chartElId]) {
            document.getElementById(tableElId).innerHTML = "<div style='padding:10px;color:#666;'>No data yet.</div>";
          }
          return;
        }

        const runs = sortRunsAsc(data.runs);
        const newestMs = chooseNewestRunTs(runs);

        const xMin = etMidnightToday();
        const nowEt = data?.meta?.now_et ? etFromIso(data.meta.now_et) : etNow();
        const nowEtSafe = nowEt || etNow();

        // Build traces (and aggressively drop invalid points)
        const traces = runs.map((r, i) => {
          const isLatest = new Date(r.run_ts).getTime() === newestMs;

          const pts = (r.points || [])
            .map(p => {
              const x = etFromIso(p.target_ts);
              const y = p.mw;
              if (!x || y == null || !isFinite(Number(y))) return null;
              return { x, y: Number(y) };
            })
            .filter(p => p && p.x >= xMin);

          const frac = (runs.length <= 1) ? 1 : i / (runs.length - 1);
          const opacity = isLatest ? 1 : (0.35 + 0.55 * Math.pow(frac, 0.8));

          return {
            x: pts.map(p => p.x),
            y: pts.map(p => p.y),
            mode: "lines",
            line: { color: isLatest ? COLOR_LATEST : COLOR_OLD, width: isLatest ? 2.6 : 1.2 },
            opacity,
            hovertemplate: "%{x|%m-%d %H:%M} ET<br>%{y:.0f} MW<extra></extra>"
          };
        }).filter(t => t.x.length > 0);

        // If everything got filtered out, keep last good render.
        if (!traces.length) {
          if (LAST_GOOD[chartElId]) {
            Plotly.react(chartElId, LAST_GOOD[chartElId].traces, LAST_GOOD[chartElId].layout, LAST_GOOD[chartElId].config);
          }
          return;
        }

        // IMPORTANT: always set x-axis max (no null), otherwise Plotly flashes weird defaults.
        const xMax = computeXMaxFromTraces(traces, nowEtSafe);
        const xMaxSafe = (xMax.getTime() < nowEtSafe.getTime())
          ? new Date(nowEtSafe.getTime() + 15 * 60000)
          : xMax;

        DATA_REV[chartElId]++;

        const layout = {
          xaxis: {
            title: "Time (ET)",
            range: [xMin, xMaxSafe]
          },
          yaxis: { title: "MW" },
          showlegend: false,
          margin: { l: 60, r: 20, t: 10, b: 50 },
          shapes: [buildNowLineShape(nowEtSafe)],
          annotations: [buildNowLabelAnnotation(nowEtSafe)],
          uirevision: `${feed}-stable`,
          datarevision: DATA_REV[chartElId]
        };

        const config = { displayModeBar: false, responsive: true };

        // Use react (no teardown) => eliminates flicker/blank flashes.
        Plotly.react(chartElId, traces, layout, config);

        // Save last good state.
        LAST_GOOD[chartElId] = { traces, layout, config };

        // Table (keep your original behavior)
        buildMatrixTable(runs, tableElId);
      }

      // ---- Resize robustness: prevents "blank until I interact" ----
      function attachPlotResizer(chartElId) {
        const el = document.getElementById(chartElId);
        if (!el) return;

        const ro = new ResizeObserver(() => {
          try { Plotly.Plots.resize(el); } catch (e) {}
        });
        ro.observe(el);

        document.addEventListener("visibilitychange", () => {
          if (!document.hidden) {
            try { Plotly.Plots.resize(el); } catch (e) {}
          }
        });
      }

      attachPlotResizer("chart-7day");
      attachPlotResizer("chart-vshort");

      // Prevent overlapping refresh cycles (interval + slow network)
      let LOAD_IN_FLIGHT = false;

      async function loadAll() {
        if (LOAD_IN_FLIGHT) return;
        LOAD_IN_FLIGHT = true;

        try {
          const latest7 = await (await fetch(`/api/latest?feed=7day&area=${encodeURIComponent(AREA)}`)).json();
          if (latest7?.run_ts) {
            const t = etFromIso(latest7.run_ts);
            document.getElementById("status").textContent =
              t ? `Last ingest (7day, ET): ${fmtET(t)}` : "Last ingest (7day, ET): ?";
          } else {
            document.getElementById("status").textContent = "No data";
          }

          await renderPanel("7day", "chart-7day", "badge-7day", "table-7day", 72);
          await renderPanel("vshort", "chart-vshort", "badge-vshort", "table-vshort", 24);
        } catch (e) {
          // Don't nuke charts on transient errors. Just show status.
          document.getElementById("status").textContent = "Error loading data";
          console.error(e);
        } finally {
          LOAD_IN_FLIGHT = false;
        }
      }

      loadAll();
      setInterval(loadAll, 60000);
    </script>
  </body>
</html>
