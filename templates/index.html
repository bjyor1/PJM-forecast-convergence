<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PJM Load Forecast Convergence</title>

    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 16px;
      }

      #chart {
        width: 100%;
        height: 70vh;
      }

      .row {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .badge {
        padding: 6px 10px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 14px;
      }

      .hint {
        color: #666;
        font-size: 13px;
        margin-top: 6px;
      }

      .section-title {
        margin: 18px 0 8px;
        font-size: 16px;
        font-weight: 650;
      }

      .table-wrap {
        border: 1px solid #e5e5e5;
        border-radius: 10px;
        overflow: hidden;
      }

      .table-scroll {
        overflow: auto;
        max-height: 55vh;
        background: #fff;
      }

      table {
        border-collapse: collapse;
        width: max-content;
        min-width: 100%;
      }

      th, td {
        border: 1px solid #eee;
        padding: 6px 8px;
        font-size: 12px;
        white-space: nowrap;
      }

      th {
        position: sticky;
        top: 0;
        background: #fafafa;
        z-index: 2;
        font-weight: 650;
      }

      th.sticky-left, td.sticky-left {
        position: sticky;
        left: 0;
        z-index: 3;
        background: #fafafa;
        font-weight: 650;
      }

      td.sticky-left {
        background: #fff;
        font-weight: 600;
      }

      .cell {
        text-align: right;
        min-width: 84px;
      }

      .mono {
        font-variant-numeric: tabular-nums;
      }

      .legend {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
        color: #666;
        font-size: 13px;
        margin-bottom: 8px;
      }

      .swatch {
        width: 16px;
        height: 10px;
        border-radius: 2px;
        border: 1px solid rgba(0,0,0,0.08);
      }
    </style>
  </head>

  <body>
    <div class="row">
      <h2 style="margin: 0;">PJM Load Forecast Convergence</h2>
      <div class="badge" id="status">Loading…</div>
    </div>
    <div class="hint">
      Chart: latest run stands out. Table: colors are relative per load-hour row (green = lower, red = higher). Times in ET.
    </div>

    <div id="chart"></div>

    <div class="section-title">Forecast Matrix (Load datetime × Forecast release)</div>
    <div class="legend">
      <div class="row" style="gap:8px;">
        <div class="swatch" style="background: rgba(40, 167, 69, 0.65);"></div>
        <div>Lower (within row)</div>
      </div>
      <div class="row" style="gap:8px;">
        <div class="swatch" style="background: rgba(220, 53, 69, 0.65);"></div>
        <div>Higher (within row)</div>
      </div>
      <div class="row" style="gap:8px;">
        <div class="swatch" style="background: rgba(0, 0, 0, 0.04);"></div>
        <div>Middle / missing</div>
      </div>
    </div>

    <div class="table-wrap">
      <div class="table-scroll" id="table-container"></div>
    </div>

    <script>
      const AREA = "RTO_COMBINED";
      const SINCE_HOURS = 12;
      const TIMEZONE = "America/New_York";

      // Chart styling (latest red, history blue)
      const COLOR_LATEST = "#d62728";
      const COLOR_OLD = "#1f77b4";

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function toETDate(utcIso) {
        const d = new Date(utcIso);
        return new Date(d.toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function nowETDate() {
        return new Date(new Date().toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function fmtET(dt) {
        const y = dt.getFullYear();
        const mo = String(dt.getMonth() + 1).padStart(2, "0");
        const da = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mm = String(dt.getMinutes()).padStart(2, "0");
        return `${y}-${mo}-${da} ${hh}:${mm}`;
      }

      function fmtETShort(dt) {
        const mo = String(dt.getMonth() + 1).padStart(2, "0");
        const da = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mm = String(dt.getMinutes()).padStart(2, "0");
        return `${mo}-${da} ${hh}:${mm}`;
      }

      function fmtMW(v) {
        return (Math.round(v)).toLocaleString("en-US");
      }

      // Row-relative shading: compare forecasts for the SAME load datetime across release times
      // Compute t = (value - min)/(max - min) within the row.
      // t near 0 => green, t near 1 => red, middle => neutral.
      function colorForRowRelative(t) {
        if (t === null || t === undefined || !isFinite(t)) return "rgba(0,0,0,0.03)";

        // Push intensity so it's obvious but still readable
        const distFromMid = Math.abs(t - 0.5) * 2; // 0..1
        const alpha = 0.08 + 0.70 * Math.pow(distFromMid, 0.75); // 0.08..0.78

        if (t > 0.5) {
          return `rgba(220, 53, 69, ${alpha})`; // red for higher
        } else if (t < 0.5) {
          return `rgba(40, 167, 69, ${alpha})`; // green for lower
        }
        return "rgba(0,0,0,0.03)";
      }

      function buildMatrixTable(runs) {
        // We want:
        // Rows = load datetime (target_ts in ET)
        // Cols = forecast release timestamp (run_ts in ET)

        // Sort releases oldest -> newest so columns flow in time
        const releasesSorted = [...runs].sort((a, b) => new Date(a.run_ts) - new Date(b.run_ts));

        const colRunTsUtc = releasesSorted.map(r => r.run_ts);
        const colRunTsEt = colRunTsUtc.map(ts => toETDate(ts));
        const colLabels = colRunTsEt.map(d => fmtETShort(d));

        // Collect all load datetimes across all runs (stable row set)
        const rowSet = new Set();
        releasesSorted.forEach(r => r.points.forEach(p => rowSet.add(p.target_ts)));
        const rowTargetUtc = [...rowSet].sort((a, b) => new Date(a) - new Date(b));
        const rowTargetEt = rowTargetUtc.map(ts => toETDate(ts));
        const rowLabels = rowTargetEt.map(d => fmtET(d));

        // Build a quick lookup: for each run (col), map target_ts -> mw
        const mwMaps = releasesSorted.map(r => {
          const m = new Map();
          r.points.forEach(p => m.set(p.target_ts, p.mw));
          return m;
        });

        // For each row (target_ts), compute min/max across columns (releases)
        // Only using non-missing values.
        const rowMinMax = rowTargetUtc.map(ts => {
          const vals = [];
          for (let j = 0; j < mwMaps.length; j++) {
            const v = mwMaps[j].get(ts);
            if (v !== undefined && v !== null && isFinite(v)) vals.push(v);
          }
          if (!vals.length) return { min: null, max: null };
          let mn = vals[0], mx = vals[0];
          for (let k = 1; k < vals.length; k++) {
            if (vals[k] < mn) mn = vals[k];
            if (vals[k] > mx) mx = vals[k];
          }
          return { min: mn, max: mx };
        });

        // HTML table
        let html = `<table><thead><tr>`;
        html += `<th class="sticky-left">Load datetime (ET)</th>`;
        for (let j = 0; j < colLabels.length; j++) {
          html += `<th class="mono" title="${fmtET(colRunTsEt[j])}">${colLabels[j]}</th>`;
        }
        html += `</tr></thead><tbody>`;

        // Show rows newest at top (usually more useful); flip by iterating backwards
        for (let i = rowTargetUtc.length - 1; i >= 0; i--) {
          const ts = rowTargetUtc[i];
          const label = rowLabels[i];
          const mm = rowMinMax[i];

          html += `<tr>`;
          html += `<td class="sticky-left mono">${label}</td>`;

          const denom = (mm.min !== null && mm.max !== null) ? (mm.max - mm.min) : 0;

          for (let j = 0; j < mwMaps.length; j++) {
            const mw = mwMaps[j].get(ts);

            let t = null;
            if (mw !== undefined && mw !== null && isFinite(mw) && denom > 0) {
              t = (mw - mm.min) / denom; // 0..1
            } else if (mw !== undefined && mw !== null && isFinite(mw) && denom === 0) {
              // all same in row => neutral
              t = 0.5;
            }

            const bg = colorForRowRelative(t);

            let title = "No value";
            if (mw !== undefined && mw !== null && isFinite(mw)) {
              const rankInfo = (mm.min === null || mm.max === null)
                ? ""
                : ` | row min: ${fmtMW(mm.min)} max: ${fmtMW(mm.max)}`;
              title = `Load: ${label} | Release: ${fmtET(colRunTsEt[j])} | MW: ${fmtMW(mw)}${rankInfo}`;
            }

            html += `<td class="cell mono" style="background:${bg}" title="${title}">`;
            html += (mw === undefined || mw === null || !isFinite(mw)) ? "" : fmtMW(mw);
            html += `</td>`;
          }

          html += `</tr>`;
        }

        html += `</tbody></table>`;
        document.getElementById("table-container").innerHTML = html;
      }

      async function load() {
        // ---- latest run badge ----
        const latestResp = await fetch(`/api/latest?area=${encodeURIComponent(AREA)}`);
        const latest = await latestResp.json();
        document.getElementById("status").textContent =
          latest && latest.run_ts ? `Last ingest: ${latest.run_ts}` : "No data yet";

        // ---- forecast runs ----
        const runsResp = await fetch(
          `/api/runs?area=${encodeURIComponent(AREA)}&since_hours=${encodeURIComponent(SINCE_HOURS)}`
        );
        const data = await runsResp.json();
        const runs = (data && data.runs) ? data.runs : [];
        if (!runs.length) return;

        // ===== Chart =====
        const now = new Date();
        const maxAgeMin = SINCE_HOURS * 60;
        const newestMs = Math.max(...runs.map(r => new Date(r.run_ts).getTime()));
        const traces = [];

        runs.forEach((r) => {
          const runTs = new Date(r.run_ts);
          const ageMin = (now - runTs) / 60000;
          const t = clamp(ageMin / maxAgeMin, 0, 1);

          // Your tuned fade (visible but clearly ranked)
          const curve = Math.pow(1 - t, 2.2);
          const opacity = 0.12 + 0.78 * curve;

          const isLatest = runTs.getTime() === newestMs;

          traces.push({
            x: r.points.map(p => toETDate(p.target_ts)),
            y: r.points.map(p => p.mw),
            type: "scatter",
            mode: "lines",
            line: {
              color: isLatest ? COLOR_LATEST : COLOR_OLD,
              width: isLatest ? 2.6 : 1.1
            },
            opacity: isLatest ? 1.0 : opacity,
            hovertemplate: isLatest
              ? "Hour (ET): %{x}<br>MW: %{y:,.0f}<extra>Latest</extra>"
              : "Hour (ET): %{x}<br>MW: %{y:,.0f}<extra></extra>"
          });
        });

        const layout = {
          margin: { l: 60, r: 20, t: 20, b: 40 },
          xaxis: { title: "Hour (ET)" },
          yaxis: { title: "MW" },
          showlegend: false,
          shapes: []
        };

        Plotly.newPlot("chart", traces, layout, {
          displayModeBar: false,
          responsive: true
        });

        // Now (ET) vertical line
        const nowET = nowETDate();
        Plotly.relayout("chart", {
          shapes: [
            {
              type: "line",
              xref: "x",
              yref: "paper",
              x0: nowET,
              x1: nowET,
              y0: 0,
              y1: 1,
              line: { color: "#000", width: 1, dash: "dot" }
            }
          ]
        });

        // ===== Table (swapped axes + row-relative shading) =====
        buildMatrixTable(runs);
      }

      load();
      setInterval(load, 60_000);
    </script>
  </body>
</html>
