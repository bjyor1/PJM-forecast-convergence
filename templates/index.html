<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PJM Load Forecast Convergence</title>

    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        margin: 16px;
      }

      #chart {
        width: 100%;
        height: 70vh;
      }

      .row {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .badge {
        padding: 6px 10px;
        border: 1px solid #ddd;
        border-radius: 999px;
        font-size: 14px;
      }

      .hint {
        color: #666;
        font-size: 13px;
        margin-top: 6px;
      }

      .section-title {
        margin: 18px 0 8px;
        font-size: 16px;
        font-weight: 650;
      }

      .table-wrap {
        border: 1px solid #e5e5e5;
        border-radius: 10px;
        overflow: hidden;
      }

      .table-scroll {
        overflow: auto;
        max-height: 55vh;
        background: #fff;
      }

      table {
        border-collapse: collapse;
        width: max-content;
        min-width: 100%;
      }

      th, td {
        border: 1px solid #eee;
        padding: 6px 8px;
        font-size: 12px;
        white-space: nowrap;
      }

      th {
        position: sticky;
        top: 0;
        background: #fafafa;
        z-index: 2;
        font-weight: 650;
      }

      th.sticky-left, td.sticky-left {
        position: sticky;
        left: 0;
        z-index: 3;
        background: #fafafa;
        font-weight: 650;
      }

      td.sticky-left {
        background: #fff;
        font-weight: 600;
      }

      .cell {
        text-align: right;
        min-width: 84px;
      }

      .mono {
        font-variant-numeric: tabular-nums;
      }

      .legend {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
        color: #666;
        font-size: 13px;
        margin-bottom: 8px;
      }

      .swatch {
        width: 16px;
        height: 10px;
        border-radius: 2px;
        border: 1px solid rgba(0,0,0,0.08);
      }
    </style>
  </head>

  <body>
    <div class="row">
      <h2 style="margin: 0;">PJM Load Forecast Convergence</h2>
      <div class="badge" id="status">Loading…</div>
    </div>
    <div class="hint">
      Chart: latest run is red. Table: colors are relative within each load-hour column (green = lower, red = higher). Times shown in ET.
    </div>

    <div id="chart"></div>

    <div class="section-title">Forecast Matrix (Forecast release × Load datetime)</div>
    <div class="legend">
      <div class="row" style="gap:8px;">
        <div class="swatch" style="background: rgba(40, 167, 69, 0.65);"></div>
        <div>Lower (within column)</div>
      </div>
      <div class="row" style="gap:8px;">
        <div class="swatch" style="background: rgba(220, 53, 69, 0.65);"></div>
        <div>Higher (within column)</div>
      </div>
      <div class="row" style="gap:8px;">
        <div class="swatch" style="background: rgba(0, 0, 0, 0.04);"></div>
        <div>Middle / missing</div>
      </div>
    </div>

    <div class="table-wrap">
      <div class="table-scroll" id="table-container"></div>
    </div>

    <script>
      const AREA = "RTO_COMBINED";
      const TIMEZONE = "America/New_York";

      // Keep only the latest N forecast updates (runs) for BOTH chart and table.
      const MAX_RUNS = 12;

      // Chart styling
      const COLOR_LATEST = "#d62728"; // red
      const COLOR_OLD = "#1f77b4";    // blue

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function toETDate(utcIso) {
        const d = new Date(utcIso);
        return new Date(d.toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function nowETDate() {
        return new Date(new Date().toLocaleString("en-US", { timeZone: TIMEZONE }));
      }

      function fmtET(dt) {
        const y = dt.getFullYear();
        const mo = String(dt.getMonth() + 1).padStart(2, "0");
        const da = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mm = String(dt.getMinutes()).padStart(2, "0");
        return `${y}-${mo}-${da} ${hh}:${mm}`;
      }

      function fmtETShort(dt) {
        const mo = String(dt.getMonth() + 1).padStart(2, "0");
        const da = String(dt.getDate()).padStart(2, "0");
        const hh = String(dt.getHours()).padStart(2, "0");
        const mm = String(dt.getMinutes()).padStart(2, "0");
        return `${mo}-${da} ${hh}:${mm}`;
      }

      function fmtMW(v) {
        return (Math.round(v)).toLocaleString("en-US");
      }

      // Column-relative shading helper:
      // given t in [0,1] where 0=min (green) and 1=max (red), shade by distance from mid.
      function colorForColumnRelative(t) {
        if (t === null || t === undefined || !isFinite(t)) return "rgba(0,0,0,0.03)";

        const dist = Math.abs(t - 0.5) * 2; // 0..1
        const alpha = 0.08 + 0.70 * Math.pow(dist, 0.75); // 0.08..0.78

        if (t > 0.5) return `rgba(220, 53, 69, ${alpha})`; // red
        if (t < 0.5) return `rgba(40, 167, 69, ${alpha})`; // green
        return "rgba(0,0,0,0.03)";
      }

      function pickLatestRuns(runs, maxRuns) {
        // Ensure newest are kept, but preserve chronological order for rendering if needed.
        const sorted = [...runs].sort((a, b) => new Date(a.run_ts) - new Date(b.run_ts)); // oldest->newest
        const sliced = sorted.slice(Math.max(0, sorted.length - maxRuns));
        return sliced; // still oldest->newest
      }

      function buildMatrixTable(runsLimited) {
        // Rows = forecast release timestamp (ET)
        // Cols = load datetime (ET)
        // Shading = relative within each column (same load hour)

        const runsSorted = [...runsLimited].sort((a, b) => new Date(a.run_ts) - new Date(b.run_ts)); // oldest->newest

        // Columns (load datetimes)
        const colSet = new Set();
        runsSorted.forEach(r => r.points.forEach(p => colSet.add(p.target_ts)));
        const colUtc = [...colSet].sort((a, b) => new Date(a) - new Date(b));
        const colEt = colUtc.map(ts => toETDate(ts));
        const colLabels = colEt.map(d => fmtETShort(d));

        // Lookup: runIndex -> Map(target_ts -> mw)
        const mwMaps = runsSorted.map(r => {
          const m = new Map();
          r.points.forEach(p => m.set(p.target_ts, p.mw));
          return m;
        });

        // For each column, min/max across runs
        const colMinMax = colUtc.map(ts => {
          const vals = [];
          for (let i = 0; i < mwMaps.length; i++) {
            const v = mwMaps[i].get(ts);
            if (v !== undefined && v !== null && isFinite(v)) vals.push(v);
          }
          if (!vals.length) return { min: null, max: null };
          let mn = vals[0], mx = vals[0];
          for (let k = 1; k < vals.length; k++) {
            if (vals[k] < mn) mn = vals[k];
            if (vals[k] > mx) mx = vals[k];
          }
          return { min: mn, max: mx };
        });

        let html = `<table><thead><tr>`;
        html += `<th class="sticky-left">Forecast release (ET)</th>`;
        for (let j = 0; j < colLabels.length; j++) {
          html += `<th class="mono">${colLabels[j]}</th>`;
        }
        html += `</tr></thead><tbody>`;

        // Newest release at top
        for (let i = runsSorted.length - 1; i >= 0; i--) {
          const runEt = toETDate(runsSorted[i].run_ts);
          html += `<tr>`;
          html += `<td class="sticky-left mono">${fmtET(runEt)}</td>`;

          for (let j = 0; j < colUtc.length; j++) {
            const mw = mwMaps[i].get(colUtc[j]);
            const mm = colMinMax[j];

            let t = null;
            if (mw !== undefined && mw !== null && isFinite(mw) && mm.min !== null && mm.max !== null) {
              if (mm.max !== mm.min) {
                t = (mw - mm.min) / (mm.max - mm.min);
              } else {
                t = 0.5; // all same in this column
              }
            }

            const bg = colorForColumnRelative(t);

            const title = (mw !== undefined && mw !== null && isFinite(mw))
              ? `MW: ${fmtMW(mw)} | col min: ${fmtMW(mm.min)} max: ${fmtMW(mm.max)}`
              : "No value";

            html += `<td class="cell mono" style="background:${bg}" title="${title}">`;
            html += (mw !== undefined && mw !== null && isFinite(mw)) ? fmtMW(mw) : "";
            html += `</td>`;
          }

          html += `</tr>`;
        }

        html += `</tbody></table>`;
        document.getElementById("table-container").innerHTML = html;
      }

      async function load() {
        // Badge
        const latestResp = await fetch(`/api/latest?area=${encodeURIComponent(AREA)}`);
        const latest = await latestResp.json();
        document.getElementById("status").textContent =
          latest && latest.run_ts ? `Last ingest: ${latest.run_ts}` : "No data yet";

        // Fetch more than we need, then clip to latest MAX_RUNS
        const runsResp = await fetch(`/api/runs?area=${encodeURIComponent(AREA)}&since_hours=48`);
        const data = await runsResp.json();
        const runsAll = (data && data.runs) ? data.runs : [];
        if (!runsAll.length) return;

        const runsLimited = pickLatestRuns(runsAll, MAX_RUNS);

        // ===== Chart =====
        const now = new Date();
        const newestMs = Math.max(...runsLimited.map(r => new Date(r.run_ts).getTime()));

        // Fade based on rank among the kept runs (not wall-clock time)
        // newest rank = 0, oldest rank = 1
        const traces = [];
        const n = runsLimited.length;

        runsLimited.forEach((r, idx) => {
          const runTs = new Date(r.run_ts);
          const isLatest = runTs.getTime() === newestMs;

          const tRank = (n <= 1) ? 0 : (idx / (n - 1)); // 0 oldest -> 1 newest (because runsLimited oldest->newest)
          const ageT = 1 - tRank; // 0 newest -> 1 oldest

          // Visible gradient you liked
          const curve = Math.pow(1 - ageT, 2.2);
          const opacity = 0.12 + 0.78 * curve;

          traces.push({
            x: r.points.map(p => toETDate(p.target_ts)),
            y: r.points.map(p => p.mw),
            type: "scatter",
            mode: "lines",
            line: {
              color: isLatest ? COLOR_LATEST : COLOR_OLD,
              width: isLatest ? 2.6 : 1.1
            },
            opacity: isLatest ? 1.0 : opacity,
            hovertemplate: isLatest
              ? "Hour (ET): %{x}<br>MW: %{y:,.0f}<extra>Latest</extra>"
              : "Hour (ET): %{x}<br>MW: %{y:,.0f}<extra></extra>"
          });
        });

        const layout = {
          margin: { l: 60, r: 20, t: 20, b: 40 },
          xaxis: { title: "Hour (ET)" },
          yaxis: { title: "MW" },
          showlegend: false,
          shapes: []
        };

        Plotly.newPlot("chart", traces, layout, {
          displayModeBar: false,
          responsive: true
        });

        // Now (ET) line
        const nowET = nowETDate();
        Plotly.relayout("chart", {
          shapes: [
            {
              type: "line",
              xref: "x",
              yref: "paper",
              x0: nowET,
              x1: nowET,
              y0: 0,
              y1: 1,
              line: { color: "#000", width: 1, dash: "dot" }
            }
          ]
        });

        // ===== Table =====
        buildMatrixTable(runsLimited);
      }

      load();
      setInterval(load, 60_000);
    </script>
  </body>
</html>
